---
title: "DATA 607 Project 1"
author: "Magnus Skonberg"
date: "`r Sys.Date()`"
output: 
  openintro::lab_report: default
  html_document:
    number_sections: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r libraries, include=FALSE}
#load relevant libraries
library(tidyverse) #includes stringr package
library(stringi)
```

<style>
div.blue { background-color:#e6f0ff; border-radius: 5px; padding: 20px;}
</style>
<div class = "blue">

**Collaborators:** Dan Rosenfeld, Jered Ataky, and Rick Sughrue

*The collaborators (noted above) contributed to and collaborated on solving Project 1.*

</div> \hfill\break


## Background
In this project, we’re given a text file with chess tournament results where the information has some structure. Our job is to create an R Markdown file that generates a .CSV file (that could for example be imported into a SQL database)
with the following information for all of the players:

*Player Name | State | Total Points | Pre-Rating | Avg Opp Pre-Rating*

For the first player, the information would be:
*Gary Hua, ON, 6.0, 1794, 1605*

*1605 was calculated by using the pre-tournament opponents’ ratings of 1436, 1563, 1600, 1610, 1649, 1663, 1716, and dividing by the total number of games played.*

## Step 1

<style>
div.blue { background-color:#e6f0ff; border-radius: 5px; padding: 20px;}
</style>
<div class = "blue">

Import the data from the text file.

</div> \hfill\break



```{r}
chess_input <- read.table(url("https://raw.githubusercontent.com/Magnus-PS/CUNY-SPS-DATA-607/Project-1/tournamentinfo.txt"), sep = ",")

#head(chess_input)
```
From the output above, we can see that the header has been included and that the data is not organized. Thus, *prior to* outputting our data in the desired form, we'll have to pull variables, etc. from this set in an organized manner. We'll have to wrangle data and sort through our 'raw' data set for what is essential / desired.

## Step 2

<style>
div.blue { background-color:#e6f0ff; border-radius: 5px; padding: 20px;}
</style>
<div class = "blue">

Remove header, "- - -" (dashed lines), and "  " excess white spaces.

</div> \hfill\break

```{r}
#Remove header
chess_input <- chess_input[-c(1:4),]

#Exclude every 3rd row (of dashed lines)
i <- seq(0, 192, 3)
chess_input <- chess_input[-i]

#Compress white space for readability
chess_input <- str_replace_all(chess_input, "\\s+", " ")

#head(chess_input)

```

The result of our *processed data* is alternating rows of values where the values themselves are separated by "|"s.

**Odd rows**: ID | Player Name | Total Pts | W/L/D Opp# ...

**Even rows**: State | USCF ID | Rtg Pre -> Post | ...

## Step 3

<style>
div.blue { background-color:#e6f0ff; border-radius: 5px; padding: 20px;}
</style>
<div class = "blue">

Sort by value row value (even v odd) to simplify later extraction. 

</div> \hfill\break

```{r}

o_rows <- seq(1, 128, 2)
e_rows <- seq(2, 128, 2)
  
o_chess <- unlist(data.frame(x=chess_input[o_rows]))
e_chess <- unlist(data.frame(x=chess_input[e_rows]))

#head(o_chess)
#head(e_chess)

```
We now have 2 vectors (o_chess and e_chess) produced via unlist() to contain all their atomic components. From each of these vectors, we can begin to use regular expressions to extract *essential components* from each vector.

## Step 4

<style>
div.blue { background-color:#e6f0ff; border-radius: 5px; padding: 20px;}
</style>
<div class = "blue">

Extract *essential components* from each vector: *Player Name | State | Total Points | Pre-Rating*

and later *Avg Opp Pre-Rating*.

</div> \hfill\break


```{r}
#Extract player IDs: 
id<-unlist(str_extract_all(o_chess,"\\d{1,2} \\| "))
id<-unlist(str_extract_all(id, "\\d{1,2}"))
#head(id)

#Extract player names:
name <-unlist(str_extract_all(o_chess,"\\w+ ?\\w+ \\w+"))
#head(name)

#Extract player point total:
pt_total <-unlist(str_extract_all(o_chess,"\\d.\\d"))
#head(pt_total)

#Extract player state:
state <-unlist(str_extract_all(e_chess, " \\w{2} \\| "))
state<-unlist(str_extract_all(state, "\\w{2}"))
#head(state)

#Extract player pre-rating:
prerating <-unlist(str_extract_all(e_chess, "(R:\\s*)(\\d+)"))
prerating <-as.numeric(unlist(str_extract_all(prerating, "(\\d+)")))
#prerating
```
At this point, we've extracted the player's ID, name, point total, state, and prerating. Prerating has been stored as a double for later purposes.

We would like to combine what we've extracted (the variables of interest) into one table but before we can do so we have one more variable to compute ... the average opponent ranking.

## Step 5

<style>
div.blue { background-color:#e6f0ff; border-radius: 5px; padding: 20px;}
</style>
<div class = "blue">

Compute the *Avg Opp Pre-Rating*.

</div> \hfill\break

We're going to build a matrix of opponent ID#s, replace these numbers with their corresponding prerating and then take the average across each row to compute the *Avg Opp Pre-Rating*.

```{r}
#Extract the entire row from the pt_total onward, set missing values @ B,H,U and X to be " 0" and then extract digits.

opp_ids<-unlist(str_extract_all(o_chess,"\\|[0-9].*"))
opp_ids<-str_replace_all(opp_ids, "[BHUX]", " 0")
opp_ids<-str_extract_all(opp_ids,"\\s\\d{1,2}")

#Convert into numeric matrix and from 64 x 7 to 7 x 64.

opp_ids_m <- matrix(unlist(opp_ids),  byrow= TRUE, nrow = length(opp_ids))
opp_ids_m <- t(apply(opp_ids_m, 1, as.numeric))

#Use embedded for loops to iterate over rows and columns. If the entry is 0, replace it with NA. Otherwise, replace the id# with its corresponding preratings.

for (i in 1:nrow(opp_ids_m)) {
  for (j in 1:ncol(opp_ids_m)) {
    if (opp_ids_m[i,j] == 0){
      opp_ids_m[i,j] == NA
    } else {
      opp_ids_m[i,j] <- prerating[opp_ids_m[i,j]]
    }
  }
}

#Note: if an error message pops up for the for loop portion, please clear objects from workspace and run again.


#Take the average value per row while omitting missing values.
avg_opp_rating <- c(rowMeans(opp_ids_m, na.rm = TRUE))
avg_opp_rating <- round(avg_opp_rating)

avg_opp_rating
```

At this point, we have extracted all the essential components and all we have to do is combine and export them to .csv.

## Step 6

<style>
div.blue { background-color:#e6f0ff; border-radius: 5px; padding: 20px;}
</style>
<div class = "blue">

Combine desired components into dataframe and export to .csv.

</div> \hfill\break


```{r}
#Combine desired components into dataframe
combined <- data.frame(name, state, pt_total, prerating, avg_opp_rating)
colnames(combined) <- c("Player Name", "Player's State", "Point Total", "Pre Rating", "Avg Opponent Rating") #waiting to calculate and add avg_opp_rating
combined

#Export to .csv: relative code not included per grading rubric.
#To execute: uncomment out, enter file path, replace '\' with '/' and run.

#write.csv(combined,"[ENTER FILE PATH HERE]//chess_combined.csv", row.names = FALSE)


```
